// *** Globally used functions ***

INCLUDE ~%MOD_FOLDER%/lib/campaigns.tph~

// Updates class description in ALL available clastext tables
DEFINE_ACTION_FUNCTION UPDATE_CLASS_DESC
INT_VAR
  newDesc = "-1"
STR_VAR
  className = ~~
BEGIN
  OUTER_SET finished = 0

  ACTION_IF (FILE_EXISTS_IN_GAME ~campaign.2da~) BEGIN
    COPY_EXISTING - ~campaign.2da~ ~override~
      COUNT_2DA_COLS cmpNumCols
      COUNT_2DA_ROWS cmpNumCols cmpNumRows
      PATCH_IF (cmpNumRows > 0) BEGIN
        READ_2DA_ENTRY 0 0 cmpNumCols cmpName
      END ELSE BEGIN
        TEXT_SPRINT cmpName ~~
      END
      PATCH_IF (NOT ~%cmpName%~ STRING_EQUAL_CASE ~WORLDSCRIPT~) BEGIN
        FOR (cmpRow = 0; cmpRow < cmpNumRows; ++cmpRow) BEGIN
          READ_2DA_ENTRY cmpRow 0 cmpNumCols cmpName
          INNER_ACTION BEGIN
            LAF GET_CAMPAIGN_INFO STR_VAR campaign = EVAL ~%cmpName%~ RET cmp_clastext END
            ACTION_IF (NOT ~%cmp_clastext%~ STRING_EQUAL ~~) BEGIN
              LAF __UPDATE_CLASS_DESC
              INT_VAR
                newDesc = newDesc
              STR_VAR
                clastextFile = EVAL ~%cmp_clastext%.2da~
                className = EVAL ~%className%~
              END
            END
          END
        END
        SET finished = 1
      END
  END

  // executed when campaign.2da is not available or empty
  ACTION_IF (finished = 0) BEGIN
    LAF __UPDATE_CLASS_DESC
    INT_VAR
      newDesc = newDesc
    STR_VAR
      clastextFile = ~clastext.2da~
      className = EVAL ~%className%~
    END
  END
END

DEFINE_ACTION_FUNCTION __UPDATE_CLASS_DESC
INT_VAR
  newDesc = "-1"
STR_VAR
  clastextFile = ~~
  className = ~~
BEGIN
  ACTION_IF (newDesc >= 0 && NOT ~%className%~ STRING_EQUAL ~~) BEGIN
    COPY_EXISTING ~%clastextFile%~ ~override~
      COUNT_2DA_COLS numCols
      COUNT_2DA_ROWS numCols numRows
      FOR (row = 0; row < numRows; ++row) BEGIN
        READ_2DA_ENTRY row 0 numCols name
        PATCH_IF (~%name%~ STRING_EQUAL_CASE ~%className%~) BEGIN
          READ_2DA_ENTRY row 4 numCols descStrref
          PATCH_IF (descStrref >= 0) BEGIN
            SET_2DA_ENTRY row 4 numCols ~%newDesc%~
            SET row = numRows
          END
        END
      END
    BUT_ONLY IF_EXISTS
  END
END


/**
 * Adds a new entry to the current CLAB table
 * INT_VAR level  The level where to add the new entry
 * STR_VAR entry  The full entry to add (including GA/AP prefix)
 * RET success    Returns nonzero on success, zero otherwise.
 */
DEFINE_PATCH_FUNCTION ADD_CLAB_ENTRY
INT_VAR
  level = 0
  pretty_print = 1
STR_VAR
  entry = ~~  // full entry to add (including GA/AP prefix)
RET
  success
BEGIN
  SET success = 0
  COUNT_2DA_COLS numCols
  COUNT_2DA_ROWS numCols numRows
  PATCH_IF (level > 0 AND level < numCols AND NOT ~%entry%~ STR_EQ ~~) BEGIN
    READ_2DA_ENTRY 1 0 1 defEntry

    // try adding entry to existing line first
    FOR (row = 0; row < numRows; row += 1) BEGIN
      READ_2DA_ENTRY row level numCols curEntry
      PATCH_IF (~%curEntry%~ STR_EQ ~%defEntry%~) BEGIN
        SET_2DA_ENTRY row level numCols ~%entry%~
        SET success = 1
        SET row = numRows
      END
    END

    // new CLAB line required?
    PATCH_IF (NOT success) BEGIN
      SET index = numRows + 1
      TEXT_SPRINT newRow ~ABILITY%index%~
      FOR (col = 1; col < numCols; col += 1) BEGIN
        PATCH_IF (col = level) BEGIN
          TEXT_SPRINT newRow ~%newRow%   %entry%~
        END ELSE BEGIN
          TEXT_SPRINT newRow ~%newRow%   %defEntry%~
        END
      END
      INSERT_2DA_ROW numRows numCols ~%newRow%~
      SET success = 1
    END

    PATCH_IF (success AND pretty_print) BEGIN
      PRETTY_PRINT_2DA
    END
  END
END


/**
 * Returns the first available script block containing the specified search string (as regular expression).
 * INT_VAR start_offset   Optional offset where to start searching. (Default: 0)
 * INT_VAR reverse        Specify zero to apply a forward search, or non-zero to apply a backwards seearch from "start_offset". (Default: 0)
 * STR_VAR search_regexp  The search string as regular expression. Must be non-empty.
 * RET script_block       The full script block as string when found, empty string otherwise.
 * RET start_offset       Start offset of the script block when found, -1 otherwise.
 * RET end_offset         End offset (directly behind closing "END") of the script block when found, -1 otherwise.
 */
DEFINE_PATCH_FUNCTION GET_SCRIPT_BLOCK
INT_VAR
  start_offset  = 0
  reverse       = 0
STR_VAR
  search_regexp = ~~
RET
  script_block
  start_offset
  end_offset
BEGIN
  SET offset = start_offset
  PATCH_IF (offset < 0) BEGIN SET offset = 0 END
  PATCH_IF (offset > BUFFER_LENGTH) BEGIN SET offset = BUFFER_LENGTH END

  TEXT_SPRINT script_block ~~
  SET start_offset = "-1"
  SET end_offset = "-1"

  PATCH_IF (NOT ~%search_regexp%~ STR_EQ ~~) BEGIN
    PATCH_IF (reverse) BEGIN
      SET offset = RINDEX_BUFFER(~%search_regexp%~ offset)
    END ELSE BEGIN
      SET offset = INDEX_BUFFER(~%search_regexp%~ offset)
    END

    PATCH_IF (offset >= 0) BEGIN
      SET ofsStart = RINDEX_BUFFER(~^IF$~ offset)
      PATCH_IF (ofsStart >= 0) BEGIN
        SET ofsEnd = INDEX_BUFFER(~^END$~ offset)
        PATCH_IF (ofsEnd >= 0) BEGIN
          SET ofsEnd += 3
          READ_ASCII ofsStart script_block (ofsEnd - ofsStart)
          SET start_offset = ofsStart
          SET end_offset = ofsEnd
        END
      END
    END
  END
END


/**
 * Attempts to return a specific entry found in the same row as another entry matching a search string.
 * INT_VAR start_row      The row to start the search. 2DA header rows are automatically skipped. (Default: 0)
 * INT_VAR column         The column containing the content to return.
 * INT_VAR search_column  The column to search for "search_text".
 * STR_VAR search_text    The search text.
 * RET row                The row index where a match has been found, -1 otherwise. Does not include 2DA header rows.
 * RET value              The content found at the specified column if a match has been found, empty string otherwise.
 */
DEFINE_PATCH_FUNCTION FIND_2DA_VALUE
INT_VAR
  start_row = 0
  column = 1
  search_column = 0
STR_VAR
  search_text = ~~
RET
  row
  value
BEGIN
  SET row = "-1"
  TEXT_SPRINT value ~~

  PATCH_IF (NOT ~%search_text%~ STR_EQ ~~ && column >= 0 && search_column >= 0) BEGIN
    COUNT_2DA_COLS numCols
    COUNT_2DA_ROWS numCols numRows
    PATCH_IF (column < numCols && search_column < numCols) BEGIN
      SET offset = (numCols > 2) ? 0 : 2
      SET idx = start_row + offset
      FOR (idx = idx; idx < numRows; ++idx) BEGIN
        READ_2DA_ENTRY idx search_column numCols entry
        PATCH_IF (~%entry%~ STR_EQ ~%search_text%~) BEGIN
          READ_2DA_ENTRY idx column numCols value
          SET row = idx - offset
          SET idx = numRows
        END
      END
    END
  END
END
